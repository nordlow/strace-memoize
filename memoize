#!/usr/bin/env python3

# TODO use gcc -pipe
# TODO parse 'st_mtime using Python's datetime.strptime(some_string, '')

import sys
import os
import subprocess
import os.path
import re
import hashlib
import tempfile
import pickle                   # cPickle not available in Python3
import json

from pprint import pprint as pp
from getopt import getopt

# from dbgio import dln

# if set use modification time instead of content-hash as indentity
OPT_USE_MODTIME = False

# show results
OPT_VERBOSE = 'raw'

SYS_CALLS = ["execve", "open", "openat", "stat", "stat64", "statfs", "access"]
RAW_CALLS = ["stat"]
SYS_CALLS_AT = ["openat"]       # Linux

# content hashing algorithm
HASH_NAME = 'sha1'

INDENT_STEP = 2                 # number of spaces per indentation level

include_system_deps = True

SYSTEM_FILE_RE = re.compile(r'/+(usr|lib|lib64|dev|proc|etc|tmp)')


def _is_content_hashable_file(fname):
    """Check if FNAME is a file whose contents can be read and hashed."""
    return not fname.startswith(b'/dev/') and os.path.exists(fname)


def _indent_space(indent):
    return ' '*INDENT_STEP*indent


def _print_syscall_fnames(syscall_s, fnames, indent):
    if not fnames:
        return

    if OPT_VERBOSE == 'raw':
        print(syscall_s + ':')
        for fname in sorted(fnames):
            print(fname)
    else:
        print('syscall=' + syscall_s + '():')

        prev_dname = None

        for fname in filter(lambda fname: (include_system_deps or
                                           not (re.match(pattern=SYSTEM_FILE_RE,
                                                         string=bytes.decode(fname)))),
                            sorted(fnames, reverse=True)):

            dname = os.path.dirname(fname)
            dname_qs = '"' + bytes.decode(dname) + '"'
            bname_qs = '"' + bytes.decode(os.path.basename(fname)) + '"'

            if dname != prev_dname:
                print(_indent_space(indent) + '@ ' + dname_qs + ':')

            indent += 1
            if _is_content_hashable_file(fname):
                mtime = os.path.getmtime(fname)
                if syscall_s in ('stat', 'statfs', 'access') or os.path.isdir(fname):
                    print(_indent_space(indent) + '- ' + bname_qs + ': mtime=' + str(mtime))
                else:
                    cdata = open(fname, 'rb').read()
                    chash = hashlib.new(HASH_NAME, cdata)
                    chash_s = ' ' + HASH_NAME + "=" + chash.hexdigest()
                    print(_indent_space(indent) + '- ' + bname_qs + ': mtime=' + str(mtime) + chash_s)
            indent -= 1

            prev_dname = dname


def chash_update_tree(chash, curr):
    # pp(chash.hexdigest())
    if (isinstance(curr, bytes)):
        chash.update(curr)
    elif (isinstance(curr, str)):
        chash.update(curr.encode('utf-8'))
    elif (isinstance(curr, list) or
          isinstance(curr, tuple)):
        chash.update(repr(len(curr)).encode('utf-8'))
        for sub in curr:
            chash_update_tree(chash, sub)
    else:
        raise Exception("Handle curr type")


def store_in_cache(execve_input):
    # store
    first_execve_chash = hashlib.new(HASH_NAME)
    chash_update_tree(first_execve_chash, execve_input)
    hexdigest = first_execve_chash.hexdigest()
    cache_dir_path = os.path.join(os.path.expanduser('~/.cache'),
                                  'memoize',
                                  hexdigest[0:2], hexdigest[2:4], hexdigest[4:])
    pp(cache_dir_path)
    os.makedirs(name=cache_dir_path, exist_ok=True)


def memoized_run(args, trace_childs=True):

    indent = 0

    trace = []                  # trace tree

    fnames_open_rdonly = set()
    fnames_open_wronly = set()
    fnames_open_rdwr = set()
    fnames_stat = set()
    fnames_statfs = set()
    fnames_openat = set()
    fnames_access = set()

    first_execve_input = None

    with tempfile.NamedTemporaryFile() as out_file:

        # collect flags
        strace_std_flags = ['-v', '-s4096']
        if trace_childs:
            strace_std_flags.append('-f')
        outfile_flags = ['-o', out_file.name]
        sys_calls_flags = ['-e', 'trace=' + ','.join(SYS_CALLS + SYS_CALLS_AT)]
        strace_cmd = ['strace'] + strace_std_flags + outfile_flags + sys_calls_flags + args

        ret = subprocess.run(args=strace_cmd, shell=False)

        out_file.seek(0)              # reset it
        for out_line in out_file:
            if b'ENOENT' not in out_line: # skip failing calls
                # print(out_line)

                pid_, out_rest = out_line.split(None, 1)

                pid = int(pid_) # decode PID integer
                # print(pid)

                try:
                    syscall, out_rest = out_rest.split(b'(', 1)
                    syscall_s = bytes.decode(syscall)
                    # print(syscall_s)

                    fname, out_rest = out_rest.split(b', ', 1)
                    fname = os.path.normpath(fname[1:-1])

                    if (fname.startswith(b'//usr') or
                        fname.startswith(b'//lib')):
                        fname = fname[1:] # skip first slash

                    # in decreasing probability
                    if syscall == b'execve':
                        # get args
                        _args, out_rest = out_rest.split(b'], [', 1)
                        argv = eval(_args[1:]) # tuple of strings

                        # get environment
                        _env, out_rest = out_rest.split(b']) = ', 1)
                        env = eval(_env) # tuple of strings containing ENV_VAR=VALE

                        # store and fingerprint
                        execve_input = (syscall, fname, argv, env)
                        if first_execve_input is None:
                            first_execve_input = execve_input
                        trace.append(execve_input)

                    elif syscall == b'stat':
                        fnames_stat.add(fname)
                    elif syscall == b'statfs':
                        fnames_statfs.add(fname)
                    elif syscall == b'openat':
                        fnames_openat.add(fname)
                        # print(fname, out_rest)
                    elif syscall == b'open':
                        if out_rest.startswith(b'O_RDONLY'): # read-only
                            fnames_open_rdonly.add(fname)
                        elif out_rest.startswith(b'O_WRONLY'): # write-only
                            fnames_open_wronly.add(fname)
                        elif out_rest.startswith(b'O_RDWR'): # read-write
                            fnames_open_rdwr.add(fname)
                        else:
                            assert(False)
                    elif syscall == b'access':
                        fnames_access.add(fname)
                    else:
                        print('Handle system call ' + syscall_s)

                except ValueError:
                    pass

        store_in_cache(first_execve_input)

        if OPT_VERBOSE:

            print("\n============================= TRACE RESULTS ===================================\n")

            if OPT_VERBOSE:
                indent += 1
                _print_syscall_fnames(syscall_s='stat', fnames=fnames_stat, indent=indent)
                _print_syscall_fnames(syscall_s='statfs', fnames=fnames_statfs, indent=indent)
                _print_syscall_fnames(syscall_s='access', fnames=fnames_access, indent=indent)
                _print_syscall_fnames(syscall_s='open-rdonly', fnames=fnames_open_rdonly, indent=indent)
                _print_syscall_fnames(syscall_s='open-wronly', fnames=fnames_open_wronly, indent=indent)
                _print_syscall_fnames(syscall_s='open-rdwr', fnames=fnames_open_rdwr, indent=indent)
                _print_syscall_fnames(syscall_s='openat', fnames=fnames_openat, indent=indent)

        return (ret, trace)


if __name__ == '__main__':

    opts, args = getopt(sys.argv[1:], 'tdv:')

    for opt, value in opts:
        if opt == '-t':
            OPT_USE_MODTIME = True
        if opt == '-v':
            OPT_VERBOSE = True

    completedProcess, trace = memoized_run(args)
    # pp(trace)
    sys.exit(completedProcess.returncode)
