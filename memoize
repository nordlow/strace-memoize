#!/usr/bin/env python3

import sys
import os
import subprocess
import os.path
import re
import hashlib
import tempfile
import pickle                   # cPickle not available in Python3
import json

from pprint import pprint as pp
from getopt import getopt

# from dbgio import dln

# if set use modification time instead of content-hash as indentity
OPT_USE_MODTIME = False

SYS_CALLS = ["open", "openat", "stat", "stat64", "statfs", "access"]
SYS_CALLS_AT = ["openat"]       # Linux

# content hashing algorithm
HASH_NAME = 'md5'

INDENT_STEP = 2                 # number of spaces per indentation level

include_system_deps = True

SYSTEM_FILE_RE = re.compile(r'/+(usr|lib|lib64|dev|proc|etc|tmp)')


def _is_nonvolatile_existing_file(fname):
    return fname != b'/dev/urandom' and os.path.exists(fname)


def _indent_space(indent):
    return ' '*INDENT_STEP*indent


def _print_syscall_fnames(syscall_s, fnames, indent):
    if (not fnames):
        return

    print('syscall=' + syscall_s + '():')

    prev_dname = None

    for fname in filter(lambda fname: (include_system_deps or
                                       not (re.match(pattern=SYSTEM_FILE_RE,
                                                     string=bytes.decode(fname)))),
                        sorted(fnames, reverse=True)):

        dname = os.path.dirname(fname)
        dname_qs = '"' + bytes.decode(dname) + '/"'
        bname_qs = '"' + bytes.decode(os.path.basename(fname)) + '"'

        if dname != prev_dname:
            print(_indent_space(indent) + '@ ' + dname_qs + ':')

        indent += 1
        if _is_nonvolatile_existing_file(fname):
            mtime = os.path.getmtime(fname)
            if syscall_s in ('stat', 'statfs', 'access') or os.path.isdir(fname):
                print(_indent_space(indent) + '- ' + bname_qs + ': mtime=' + str(mtime))
            else:
                cdata = open(fname, 'rb').read()
                chash = hashlib.new(HASH_NAME, cdata)
                chash_s = ' ' + HASH_NAME + "=" + chash.hexdigest()
                print(_indent_space(indent) + '- ' + bname_qs + ': mtime=' + str(mtime) + chash_s)
        indent -= 1

        prev_dname = dname

def memoized_run(args, trace_childs=True):

    indent = 0

    fnames_open_rdonly = set()
    fnames_open_wronly = set()
    fnames_open_rdwr = set()
    fnames_stat = set()
    fnames_statfs = set()
    fnames_openat = set()
    fnames_access = set()

    with tempfile.NamedTemporaryFile() as out_file:

        # collect flags
        strace_flags = []
        if trace_childs:
            strace_flags.append('-f')
        outfile_flags = ['-o', out_file.name]
        sys_calls_flags = ['-e', 'trace=' + ','.join(SYS_CALLS + SYS_CALLS_AT)]
        strace_args = ['strace'] + strace_flags + outfile_flags + sys_calls_flags + args

        ret = subprocess.run(args=strace_args, shell=False)

        out_file.seek(0)              # reset it
        for out_line in out_file:
            if b'ENOENT' not in out_line: # skip failing calls

                pid_, out_line = out_line.split(None, 1)

                pid = int(pid_) # decode PID integer
                # print(pid)

                try:
                    syscall, out_line = out_line.split(b'(', 1)
                    syscall_s = bytes.decode(syscall)
                    # print(syscall_s)

                    fname, out_line = out_line.split(b', ', 1)
                    fname = os.path.normpath(fname[1:-1])

                    if fname.startswith(b'//lib') or fname.startswith(b'//lib'):
                        fname = fname[1:]

                    # in decreasing probability
                    if syscall == b'stat':
                        fnames_stat.add(fname)
                    elif syscall == b'statfs':
                        fnames_statfs.add(fname)
                    elif syscall == b'openat':
                        fnames_openat.add(fname)
                        # print(fname, out_line)
                    elif syscall == b'open':
                        if out_line.startswith(b'O_RDONLY'): # read-only
                            fnames_open_rdonly.add(fname)
                        elif out_line.startswith(b'O_WRONLY'): # write-only
                            fnames_open_wronly.add(fname)
                        elif out_line.startswith(b'O_RDWR'): # read-write
                            fnames_open_rdwr.add(fname)
                        else:
                            assert(False)
                    elif syscall == b'access':
                        fnames_access.add(fname)
                    else:
                        print('Handle system call ' + syscall_s)

                except ValueError:
                    pass

        prev_dname = None

        indent += 1

        print("\n============================= TRACE RESULTS ===================================\n")

        _print_syscall_fnames(syscall_s='stat', fnames=fnames_stat, indent=indent)
        _print_syscall_fnames(syscall_s='statfs', fnames=fnames_statfs, indent=indent)
        _print_syscall_fnames(syscall_s='access', fnames=fnames_access, indent=indent)
        _print_syscall_fnames(syscall_s='open-rdonly', fnames=fnames_open_rdonly, indent=indent)
        _print_syscall_fnames(syscall_s='open-wronly', fnames=fnames_open_wronly, indent=indent)
        _print_syscall_fnames(syscall_s='open-rdwr', fnames=fnames_open_rdwr, indent=indent)
        _print_syscall_fnames(syscall_s='openat', fnames=fnames_openat, indent=indent)

        return ret


if __name__ == '__main__':

    opts, args = getopt(sys.argv[1:], 'td:')

    for opt, value in opts:
        if opt == '-t':
            OPT_USE_MODTIME = True

    completedProcess = memoized_run(args)
    sys.exit(completedProcess.returncode)
