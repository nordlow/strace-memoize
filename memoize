#!/usr/bin/env python3

# TODO ask on StackExchange if there's a flag to strace to not show failing
# system calls

# TODO use gcc -pipe

# TODO parse 'st_mtime using Python's datetime.strptime(some_string, '')

# TODO Replace encode('utf-8') => encode('ascii')

# TODO Should we include result of `os.getcwd()` in execve_chash?

import sys
import os
import subprocess
import os.path
import re
import hashlib
import tempfile
import pickle                   # cPickle not available in Python3
import json

from pprint import pprint as pp
from getopt import getopt

# from dbgio import dln

# if set use modification time instead of content-hash as indentity
OPT_USE_MODTIME = False

# show results
OPT_VERBOSE = False # False, True, 'raw'

SYS_CALLS = ["execve", "open", "openat", "stat", "stat64", "statfs", "access"]
RAW_CALLS = ["stat"]
SYS_CALLS_AT = ["openat"]       # Linux

# content hashing algorithm
HASH_NAME = 'sha1'

INDENT_STEP = 2                 # number of spaces per indentation level

include_system_deps = True

SYSTEM_FILE_RE = re.compile(r'/+(usr|lib|lib64|dev|proc|etc|tmp)')

CACHE_DIR = '~/.cache'          # cache directory

ENCODING = 'utf-8'              # default text encoding


def dir_is_modified_since(dname, mtime):
    return os.path.getmtime(dname) != mtime # robust to NFS time skews


def file_is_modified_since(fname, mtime, chash):
    if os.path.getmtime(fname) != mtime: # robust to NFS time skews
        return hashlib.new(HASH_NAME, open(fname, 'rb').read) != chash
    else:
        return False


def _is_content_hashable_file(fname):
    """Check if FNAME is a file whose contents can be read and hashed."""
    return not fname.startswith(b'/dev/') and os.path.exists(fname)


def _indent_space(indent):
    return ' '*INDENT_STEP*indent


def _print_syscall_fnames(syscall_s, fnames, indent):
    if not fnames:
        return

    if OPT_VERBOSE == 'raw':
        print(syscall_s + ':')
        for fname in sorted(fnames):
            print(fname)
    else:
        print('syscall=' + syscall_s + '():')

        prev_dname = None

        for fname in filter(lambda fname: (include_system_deps or
                                           not (re.match(pattern=SYSTEM_FILE_RE,
                                                         string=bytes.decode(fname)))),
                            sorted(fnames, reverse=True)):

            dname = os.path.dirname(fname)
            dname_qs = '"' + bytes.decode(dname) + '"'
            bname_qs = '"' + bytes.decode(os.path.basename(fname)) + '"'

            if dname != prev_dname:
                print(_indent_space(indent) + '@ ' + dname_qs + ':')

            indent += 1
            if _is_content_hashable_file(fname):
                mtime = os.path.getmtime(fname)
                if syscall_s in ('stat', 'statfs', 'access') or os.path.isdir(fname):
                    print(_indent_space(indent) + '- ' + bname_qs + ': mtime=' + str(mtime))
                else:
                    chash = hashlib.new(HASH_NAME, open(fname, 'rb').read())
                    chash_s = ' ' + HASH_NAME + "=" + chash.hexdigest()
                    print(_indent_space(indent) + '- ' + bname_qs + ': mtime=' + str(mtime) + chash_s)
            indent -= 1

            prev_dname = dname


def chash_update_tree(chash, curr):
    # pp(chash.hexdigest())
    if (isinstance(curr, bytes)):
        chash.update(curr)
    elif (isinstance(curr, str)):
        chash.update(curr.encode(ENCODING))
    elif (isinstance(curr, list) or
          isinstance(curr, tuple)):
        chash.update(repr(len(curr)).encode(ENCODING))
        for sub in curr:
            chash_update_tree(chash, sub)
    elif (isinstance(curr, dict)):
        chash.update(repr(len(curr)).encode(ENCODING))
        for sub_key, sub_value in curr.items():
            chash_update_tree(chash, sub_key)
            chash_update_tree(chash, sub_value)
    elif (isinstance(curr, float)):
        chash.update(str(curr).encode(ENCODING))
    elif (isinstance(curr, filter)):
        for sub in curr:
            chash_update_tree(chash, sub)
    else:
        raise Exception("Handle curr type")


def execve_chash(execve_call):
    """Create fingerprint (content hash) of call to system function `execve()`
described by `execve_call`.

    """
    chash = hashlib.new(HASH_NAME)
    execve_fname = execve_call[1]
    chash.update(open(execve_fname, 'rb').read()) # contents of executed binary
    chash.update(os.getcwd().encode(ENCODING))     # current working directory. TODO needed?
    chash_update_tree(chash, execve_call)         # the rest
    return chash


def store_in_cache(execve_call, fnames_all):
    # create cache directory path
    execve_hexdigest = execve_chash(execve_call).hexdigest()
    cache_dir_path = os.path.join(os.path.expanduser(CACHE_DIR), 'memoize',
                                  execve_hexdigest[0:2],
                                  execve_hexdigest[2:4],
                                  execve_hexdigest[4:])
    os.makedirs(name=cache_dir_path, exist_ok=True)
    # print("cache_dir_path:", cache_dir_path)

    # fingerprint inputs
    inputs_chash = hashlib.new(HASH_NAME)

    # get inputs and outputs
    rw_list = {}       # read or/and written file names => mtime and optional chash
    wr_list = set()             # written file names
    for (syscall, fnames) in fnames_all.items():
        for fname in fnames:
            if not re.match(pattern=SYSTEM_FILE_RE,
                            string=bytes.decode(fname)):

                if os.path.isdir(fname): # TODO and not directory under current working treen
                    continue

                if syscall in ['stat', 'statfs', 'access']:
                    if fname not in rw_list:
                        rw_list[fname] = os.path.getmtime(fname)
                elif syscall in ['open_rdonly',
                                 'open_wronly',
                                 'open_rdwr']:
                    rw_list[fname] = (os.path.getmtime(fname),
                                      hashlib.new(HASH_NAME,
                                                  open(fname, 'rb').read()).hexdigest())
                    if syscall in ['open_wronly',
                                   'open_rdwr']:
                        wr_list.add(fname)

    # pp(sorted(wr_list))

    rw_list_sorted_by_fname = sorted(rw_list.items()) # TODO sort by first element only
    for rw_file, rw_status in rw_list_sorted_by_fname:
        if rw_file in wr_list:
            continue            # exclude written files, because they are saved
        chash_update_tree(inputs_chash, rw_status[1]) # only content hash here

    separator = b'	'       # tab

    inputs_dir_path = os.path.join(cache_dir_path,
                                   "rw_files_content_hash:" +
                                   inputs_chash.hexdigest())
    os.makedirs(name=inputs_dir_path,
                exist_ok=True)
    inputs_mtime_chash_path = os.path.join(inputs_dir_path, "rw_files")

    with open(inputs_mtime_chash_path, 'wb') as out_file:
        for input_file, input_status in rw_list_sorted_by_fname:

            if input_file in wr_list:
                continue        # skip output files

            if isinstance(input_status, tuple):
                out_file.write(input_file +
                               separator +
                               str(input_status[0]).encode(ENCODING) +
                               separator +
                               input_status[1].encode(ENCODING) +
                               b'\n')
            else:
                out_file.write(input_file +
                               separator +
                               str(input_status[0]).encode(ENCODING) +
                               b'\n')


def memoized_run(args, trace_childs=True):

    indent = 0

    trace = []                  # trace tree

    # hash from system call name to call instances set
    fnames_all = {}
    fnames_all['open_rdonly'] = set()
    fnames_all['open_wronly'] = set()
    fnames_all['open_rdwr']   = set()
    fnames_all['stat']        = set()
    fnames_all['statfs']      = set()
    fnames_all['openat']      = set()
    fnames_all['access']      = set()

    first_execve_call = None

    with tempfile.NamedTemporaryFile() as out_file:

        # collect flags
        strace_std_flags = ['-v', '-s4096']
        if trace_childs:
            strace_std_flags.append('-f')
        outfile_flags = ['-o', out_file.name]
        sys_calls_flags = ['-e', 'trace=' +
                           ','.join(SYS_CALLS + SYS_CALLS_AT)]
        strace_cmd = ['strace'] + strace_std_flags + outfile_flags + sys_calls_flags + args

        ret = subprocess.run(args=strace_cmd, shell=False)

        out_file.seek(0)              # reset it
        for out_line in out_file:
            if b'ENOENT' not in out_line: # skip failing calls
                # print(out_line)

                pid_, out_rest = out_line.split(None, 1)

                pid = int(pid_) # decode PID integer
                # print(pid)

                try:
                    syscall, out_rest = out_rest.split(b'(', 1)
                    syscall_s = bytes.decode(syscall)
                    # print(syscall_s)

                    fname, out_rest = out_rest.split(b', ', 1)
                    fname = os.path.normpath(fname[1:-1])

                    if (fname.startswith(b'//usr') or
                        fname.startswith(b'//lib')):
                        fname = fname[1:] # skip first slash

                    # in decreasing probability
                    if syscall == b'execve':
                        # get args
                        _args, out_rest = out_rest.split(b'], [', 1)
                        argv = eval(_args[1:]) # tuple of strings

                        # get environment
                        _env, out_rest = out_rest.split(b']) = ', 1)
                        env = eval(_env) # tuple of strings containing ENV_VAR=VALE

                        # store and fingerprint
                        execve_call = (syscall, fname, argv, env)
                        if first_execve_call is None:
                            first_execve_call = execve_call
                        trace.append(execve_call)

                    elif syscall == b'stat':
                        fnames_all['stat'].add(fname)
                    elif syscall == b'statfs':
                        fnames_all['statfs'].add(fname)
                    elif syscall == b'openat':
                        fnames_all['openat'].add(fname)
                        # print(fname, out_rest)
                    elif syscall == b'open':
                        if out_rest.startswith(b'O_RDONLY'): # read-only
                            fnames_all['open_rdonly'].add(fname)
                        elif out_rest.startswith(b'O_WRONLY'): # write-only
                            fnames_all['open_wronly'].add(fname)
                        elif out_rest.startswith(b'O_RDWR'): # read-write
                            fnames_all['open_rdwr'].add(fname)
                        else:
                            raise Exception('unknown out_rest' + str(out_rest))
                    elif syscall == b'access':
                        fnames_all['access'].add(fname)
                    else:
                        print('Handle system call ' + syscall_s)

                except ValueError:
                    pass

        store_in_cache(first_execve_call, fnames_all=fnames_all)

        if OPT_VERBOSE:

            print("\n============================= TRACE RESULTS ===================================\n")

            if OPT_VERBOSE:
                indent += 1
                _print_syscall_fnames(syscall_s='stat', fnames=fnames_all['stat'], indent=indent)
                _print_syscall_fnames(syscall_s='statfs', fnames=fnames_all['statfs'], indent=indent)
                _print_syscall_fnames(syscall_s='access', fnames=fnames_all['access'], indent=indent)
                _print_syscall_fnames(syscall_s='open-rdonly', fnames=fnames_all['open_rdonly'], indent=indent)
                _print_syscall_fnames(syscall_s='open-wronly', fnames=fnames_all['open_wronly'], indent=indent)
                _print_syscall_fnames(syscall_s='open-rdwr', fnames=fnames_all['open_rdwr'], indent=indent)
                _print_syscall_fnames(syscall_s='openat', fnames=fnames_all['openat'], indent=indent)

        return (ret, trace)


if __name__ == '__main__':

    opts, args = getopt(sys.argv[1:], 'tdv:')

    for opt, value in opts:
        if opt == '-t':
            OPT_USE_MODTIME = True
        if opt == '-v':
            OPT_VERBOSE = True

    completedProcess, trace = memoized_run(args)
    # pp(trace)
    sys.exit(completedProcess.returncode)
